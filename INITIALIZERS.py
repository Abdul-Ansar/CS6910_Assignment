# -*- coding: utf-8 -*-
"""INITIALIZERS.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dJ0fhAVQ8j8etZzzGYpfW2y1GyP0lmla
"""

import numpy as np

################################################
#         Initializers
################################################

class RandomNormal():
    """
    Class for initializing weights and biases from a normal distribution.
    """
    def __init__(self, mean=0.0, stddev=1.0):
        """
        Constructor method to initialize mean and standard deviation.

        Args:
            mean (float): Mean of the normal distribution.
            stddev (float): Standard deviation of the normal distribution.
        """
        self.mean = mean
        self.stddev = stddev

    def weights_biases(self, n_prev, n_curr):
        """
        Method to generate random weights and biases.

        Args:
            n_prev (int): Number of neurons in the previous layer.
            n_curr (int): Number of neurons in the current layer.

        Returns:
            tuple: Tuple containing randomly initialized weights and biases.
        """
        W = np.random.normal(loc=self.mean, scale=self.stddev, size=(n_prev, n_curr))
        b = np.random.normal(loc=self.mean, scale=self.stddev, size=(n_curr,))
        return W, b

class XavierUniform():
    """
    Class for initializing weights and biases using Xavier uniform initialization.
    """
    def __init__(self):
        """
        Constructor method.
        """
        pass

    def weights_biases(self, n_prev, n_curr):
        """
        Method to generate weights and biases using Xavier uniform initialization.

        Args:
            n_prev (int): Number of neurons in the previous layer.
            n_curr (int): Number of neurons in the current layer.

        Returns:
            tuple: Tuple containing initialized weights and biases.
        """
        upper_bound = np.sqrt(6.0 / (n_prev + n_curr))
        lower_bound = -1 * upper_bound
        W = np.random.uniform(low=lower_bound, high=upper_bound, size=(n_prev, n_curr))
        b = np.zeros((n_curr,), dtype=np.float64)
        return W, b